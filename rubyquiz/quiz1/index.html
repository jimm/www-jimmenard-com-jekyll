<!--#set var="pagetitle" value="Ruby Quiz 1: The Solitaire Cypher" -->
<!--#include virtual="/header.html"-->

<p>Here is my solution to Ruby Quiz 1: <a
href="http://www.rubyquiz.com/quiz1.html">The Solitaire Cypher</a>. Jump down
to the <a href="#solution">solution</a> or the <a href="#xunit">unit
test</a>.</p>

<p>Back to my <a href="../">Ruby Quiz solutions page</a>.</p>


<h2 id="solution">Solution</h2>

<pre>
<span class='rb-com'>#! /usr/bin/env ruby</span>

<span class='rb-kon'>RANKS</span> = %w(A 2 3 4 5 6 7 8 9 10 J Q K)
<span class='rb-kon'>SUITS</span> = %w(C D H S)
<span class='rb-kon'>JOKER_RANK</span> = <span class='rb-str'>'joker'</span>
<span class='rb-kon'>JOKER_VALUE</span> = -1

class <span class='rb-kon'>Card</span>
    def <span class='rb-def'>Card.value_to_chr</span>(value)
	i = value
	i -= 26 while i > 26
	(i + ?A - 1).chr
    end
    def <span class='rb-def'>Card.chr_to_value</span>(chr)
	i = chr[0] - ?A + 1
	i += 26 while i &lt; 0
	i
    end

    def <span class='rb-def'>initialize</span>(rank, suit)
	@rank = rank
	@suit = suit
	if rank == <span class='rb-kon'>JOKER_RANK</span>
	    @value = <span class='rb-kon'>JOKER_VALUE</span>
	else
	    @value = (<span class='rb-kon'>SUITS</span>.index(suit) * 13) + <span class='rb-kon'>RANKS</span>.index(rank) + 1
	end
    end

    def <span class='rb-def'>to_s</span>
<span class='rb-com'># 	return @value.to_s if @value != JOKER_VALUE</span>
<span class='rb-com'># 	return @suit.to_s</span>
 	<span class='rb-str'>"#{@rank}#{@suit} #{@value.to_s}"</span>
    end

    def <span class='rb-def'>to_i</span>
	@value
    end

    def <span class='rb-def'>chr</span>
	Card.value_to_chr(@value)
    end
end

class <span class='rb-kon'>Deck</span>

    def <span class='rb-def'>initialize</span>
	@cards = []
	<span class='rb-kon'>SUITS</span>.each { | suit |
	    <span class='rb-kon'>RANKS</span>.each { | rank | @cards &lt;&lt; Card.new(rank, suit) }
	}
	@joker_a = Card.new(<span class='rb-kon'>JOKER_RANK</span>, <span class='rb-str'>'A'</span>)
	@cards &lt;&lt; @joker_a
	@joker_b = Card.new(<span class='rb-kon'>JOKER_RANK</span>, <span class='rb-str'>'B'</span>)
	@cards &lt;&lt; @joker_b
    end

    <span class='rb-com'># Keys the deck and returns itself.</span>
    def <span class='rb-def'>key</span>
	<span class='rb-com'># do nothing; keyed when initialized</span>
	self
    end

    <span class='rb-com'># Return the next keystream value as a number (not a string).</span>
    <span class='rb-com'># Keep going until we have a non-joker value.</span>
    def <span class='rb-def'>next_keystream</span>
	val = <span class='rb-kon'>JOKER_VALUE</span>
	until val != <span class='rb-kon'>JOKER_VALUE</span>
	    val = generate_next_keystream_value
	end
	val
    end

    <span class='rb-com'># Return the next keystream value as a number 1-26 (not a string).</span>
    def <span class='rb-def'>generate_next_keystream_value</span>
	move(@joker_a, 1)
	move(@joker_b, 2)
	triple_cut()
	count_cut()
	return output_number()
    end

    <span class='rb-com'># Move a card a certain distance. Wrap around the end of the deck.</span>
    def <span class='rb-def'>move</span>(card, distance)
	old_pos = @cards.index(card)
	new_pos = old_pos + distance
	new_pos -= (@cards.length-1) if new_pos >= @cards.length
	@cards[old_pos,1] = []
	@cards[new_pos,0] = [card]
    end

    <span class='rb-com'># Perform a triple cut around the two jokers. All cards above the top</span>
    <span class='rb-com'># joker move to below the bottom joker and vice versa. The jokers and the</span>
    <span class='rb-com'># cards between them do not move.</span>
    def <span class='rb-def'>triple_cut</span>
	i = @cards.index(@joker_a)
	j = @cards.index(@joker_b)
	j, i = i, j if j &lt; i	<span class='rb-com'># make sure i &lt; j</span>
	@cards = slice(j+1, -1) + slice(i, j) + slice(0, i-1)
    end

    <span class='rb-com'># Perform a count cut using the value of the bottom card. Cut the bottom</span>
    <span class='rb-com'># card's value in cards off the top of the deck and reinsert them just</span>
    <span class='rb-com'># above the bottom card.</span>
    def <span class='rb-def'>count_cut</span>
	i = @cards[@cards.length - 1].to_i
	@cards = slice(i, -2) + slice(0, i-1) + [@cards[@cards.length-1]]
    end

    <span class='rb-com'># Returns a non-nil cut of cards from the deck.</span>
    def <span class='rb-def'>slice</span>(from, to)
	slice = @cards[from..to]
	return slice || []
    end

    <span class='rb-com'># Return the output number (not letter). Convert the top card to its</span>
    <span class='rb-com'># value and count down that many cards from the top of the deck, with the</span>
    <span class='rb-com'># top card itself being card number one. Look at the card immediately</span>
    <span class='rb-com'># after your count and convert it to a letter. This is the next letter in</span>
    <span class='rb-com'># the keystream. If the output card is a joker, no letter is generated</span>
    <span class='rb-com'># this sequence. This step does not alter the deck.</span>
    def <span class='rb-def'>output_number</span>
	i = @cards[0].to_i
	i -= @cards.length if i >= @cards.length
	num = @cards[i].to_i
	num -= 26 if num > 26
	num
    end

    def <span class='rb-def'>to_s</span>
	@cards.join(<span class='rb-str'>' '</span>)
    end
end

class <span class='rb-kon'>CryptKeeper</span>

    def <span class='rb-def'>initialize</span>(deck)
	@keyed_deck = deck
    end

    def <span class='rb-def'>decrypt</span>(str)
	build_crypto(str) { | key, msg_num |
	    diff = msg_num - key
	    diff += 26 if diff &lt; 1
	    diff
	}
    end

    def <span class='rb-def'>encrypt</span>(str)
	build_crypto(str) { | key, msg_num |
	    sum = msg_num + key
	    sum -= 26 if sum > 26
	    sum
	}
    end

    <span class='rb-com'># Returns a string after yielding key/msg_num pairs and collecting</span>
    <span class='rb-com'># the results.</span>
    def <span class='rb-def'>build_crypto</span>(str)
	deck = @keyed_deck.dup
	answer = <span class='rb-str'>''</span>
	str.split(//).each { | c |
	    if c == <span class='rb-str'>' '</span>
		answer &lt;&lt; <span class='rb-str'>' '</span>
		next
	    end

	    msg_num = Card.chr_to_value(c)
	    key = deck.next_keystream
	    answer &lt;&lt; Card.value_to_chr(yield key, msg_num)
	}
	answer
    end

end

<span class='rb-com'># Prepare input argument, translating it from an arbitrary string into</span>
<span class='rb-com'># blocks of five characters, all uppercase.</span>
def <span class='rb-def'>prep_arg</span>(str)
    str = str.upcase.gsub(/[^A-Z]/, <span class='rb-str'>''</span>)
    words = []
    while str.length > 0
	words &lt;&lt; str[0...5]
	str[0...5] = <span class='rb-str'>''</span>
    end

    last_len = words[words.length-1].length
    words[words.length-1] += (<span class='rb-str'>'X'</span> * (5 - last_len)) if last_len &lt; 5
    words.join(<span class='rb-str'>' '</span>)
end

if __FILE__ == $0
    if <span class='rb-kon'>ARGV</span>[0]
	puts CryptKeeper.new(Deck.new.key).decrypt(prep_arg(<span class='rb-kon'>ARGV</span>[0]))
    else
	puts CryptKeeper.new(Deck.new.key).decrypt(<span class='rb-str'>'<span class='rb-kon'>CLEPK</span> <span class='rb-kon'>HHNIY</span> <span class='rb-kon'>CFPWH</span> <span class='rb-kon'>FDFEH</span>'</span>)
	puts CryptKeeper.new(Deck.new.key).decrypt(<span class='rb-str'>'<span class='rb-kon'>ABVAW</span> <span class='rb-kon'>LWZSY</span> <span class='rb-kon'>OORYK</span> <span class='rb-kon'>DUPVH</span>'</span>)
    end
end



<h2 id="xunit">Unit Test</h2>

<pre>
<span class='rb-com'>#! /usr/bin/env ruby</span>

require <span class='rb-str'>'test/unit.rb'</span>
require <span class='rb-str'>'test/unit/ui/console/testrunner'</span>
require <span class='rb-str'>'solitaire_cypher.rb'</span>

class <span class='rb-kon'>SolitaireCypherTest</span> &lt; <span class='rb-kon'>Test::Unit::TestCase</span>

    <span class='rb-kon'>KNOWN_PLAINTEXT</span> = <span class='rb-str'>'<span class='rb-kon'>CODEI</span> <span class='rb-kon'>NRUBY</span> <span class='rb-kon'>LIVEL</span> <span class='rb-kon'>ONGER</span>'</span>
    <span class='rb-kon'>KNOWN_CYPHER</span> = <span class='rb-str'>'<span class='rb-kon'>GLNCQ</span> <span class='rb-kon'>MJAFF</span> <span class='rb-kon'>FVOMB</span> <span class='rb-kon'>JIYCB</span>'</span>

    def <span class='rb-def'>setup</span>
	@deck = Deck.new.key
	@crypt_keeper = CryptKeeper.new(@deck)
    end

    def <span class='rb-def'>test_value_to_chr</span>
	assert_equal(<span class='rb-str'>'A'</span>, Card.value_to_chr(1))
	assert_equal(<span class='rb-str'>'Z'</span>, Card.value_to_chr(26))
    end

    def <span class='rb-def'>test_chr_to_value</span>
	assert_equal(1, Card.chr_to_value(<span class='rb-str'>"A"</span>))
	assert_equal(26, Card.chr_to_value(<span class='rb-str'>"Z"</span>))
    end

    def <span class='rb-def'>test_keystream</span>
	expected = %w(D W J X H Y R F D G)
	deck = Deck.new.key
	expected.each { | exp |
	    key = deck.next_keystream
	    assert_equal(exp, Card.value_to_chr(key))
	}
    end

    def <span class='rb-def'>test_decrypt_known_cypher</span>
	assert_equal(<span class='rb-kon'>KNOWN_PLAINTEXT</span>, @crypt_keeper.decrypt(<span class='rb-kon'>KNOWN_CYPHER</span>))
    end

    def <span class='rb-def'>test_encrypt_known_message</span>
	assert_equal(<span class='rb-kon'>KNOWN_CYPHER</span>, @crypt_keeper.encrypt(<span class='rb-kon'>KNOWN_PLAINTEXT</span>))
    end
end

Test::Unit::<span class='rb-kon'>UI</span>::Console::TestRunner.run(SolitaireCypherTest)
</pre>

<!--#include virtual="/footer.html"-->
